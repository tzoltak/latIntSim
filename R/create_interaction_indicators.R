#' @title Data transformation
#' @description
#' Computes observed indicators to be loaded by the latent variables
#' representing latent interactions
#' @param data a matrix with values of observed indicators, typically generated
#' by the [generate_observed]
#' @param indicatorsMapping a numeric (or logical) matrix with indicator names
#' in rows and latent variable names in columns describing which indicators are
#' loaded by which latent variables (non-zero cells indicate the relationship);
#' typically a matrix of factor loadings generated by the [generate_loadings]
#' @param interactionsMapping a numeric (or logical) matrix with latent
#' interaction names in rows and latent variable names in columns describing
#' which latent variables create interactions (non-zero cells indicate the
#' relationship); typically the attribute `mapping` of a result of calling the
#' [generate_latent]
#' @param center a string specifying type of centering: grand mean centering
#' ("mean", the default), no centering ("none") or residual centering ("residual")
#' @param nonredundantOnly a logical value specifying whether each latent
#' variable indicator should create only one interaction observed indicator (in
#' a given interaction); should be set to `TRUE` for the *unconstrained*
#' approach; otherwise all the combinations of indicators are used to create
#' interaction's observed indicators (and consequently constraints on their
#' random error terms should be imposed in the model specification)
#' @details
#' Function can deal also with interactions of higher order, i.e. those for
#' which there are more than two non-zero entries in the given row of the
#' `interactionsMapping`.
#' @returns `data` matrix with additional columns representing latent
#' interactions indicators; matrix with mapping of the indicators to latent
#' variables (including newly created latent interaction ones) is returned as
#' an attribute
#' @examples
#' latent <- generate_latent(nObs = 10^5, nLV = 3, nLI = 2,
#'                           r = 0.3, partR = 0.3, partRI = 0.2)
#' loadings <- generate_loadings(c(x1 = 2, x2 = 2, x3 = 2, y = 3), 0.7)
#' observed <- generate_observed(latent, loadings,
#'                               latentVariances = diag(attributes(latent)$cov))
#' head(observed)
#' observed <- create_interaction_indicators(observed, loadings,
#'                                           attributes(latent)$mapping,
#'                                           center = "mean",
#'                                           nonredundantOnly = FALSE)
#' head(observed)
#' @export
create_interaction_indicators <- function(data, indicatorsMapping,
                                          interactionsMapping,
                                          center = c("mean", "none", "residual"),
                                          nonredundantOnly = TRUE) {
  center <- match.arg(center)
  stopifnot(is.matrix(data), is.numeric(data),
            is.matrix(indicatorsMapping),
            is.numeric(indicatorsMapping) || is.logical(indicatorsMapping),
            !anyNA(indicatorsMapping),
            all(rownames(indicatorsMapping) %in% colnames(data)),
            is.matrix(interactionsMapping),
            is.numeric(interactionsMapping) || is.logical(interactionsMapping),
            !anyNA(interactionsMapping),
            all(colnames(interactionsMapping) %in% colnames(indicatorsMapping)),
            length(nonredundantOnly) == 1, nonredundantOnly %in% c(TRUE, FALSE))
  indicatorsMapping <- indicatorsMapping != 0
  stopifnot("Each inidicator must be loaded by only one latent variable." =
              all(rowSums(indicatorsMapping) %in% c(0L, 1L)))

  if (center != "none") {
    data <- data - rep(colMeans(data, na.rm = TRUE), each = nrow(data))
  }

  interactionsMapping <- interactionsMapping != 0
  for (i in seq_len(nrow(interactionsMapping))) {
    lV <- colnames(interactionsMapping)[which(interactionsMapping[i, ])]
    nLV <- length(lV)
    indicators <- vector(mode = "list", length = nLV)
    names(indicators) <- lV
    for (l in lV) {
      indicators[[l]] <- rownames(indicatorsMapping)[indicatorsMapping[, l]]
    }
    if (nonredundantOnly) {
      minNIndic <- min(sapply(indicators, length))
      indicators <- lapply(indicators, function(x, which) x[which],
                           which = seq_len(minNIndic))
      interactions <- do.call(rbind, indicators)
    } else {
      interactions <- matrix(NA_character_, nrow = length(indicators),
                             ncol = cumprod(sapply(indicators, length))[nLV],
                             dimnames = list(names(indicators), NULL))
      r1 <- 1
      r2 <- ncol(interactions)
      for (l in lV) {
        interactions[l, ] <- rep(rep(indicators[[l]], r1),
                                 each = r2 / length(indicators[[l]]))
        r1 <- r1 * length(indicators[[l]])
        r2 <- r2 / length(indicators[[l]])
      }
    }
    colnames(interactions) <- paste0(rownames(interactionsMapping)[i], "_",
                                     seq_len(ncol(interactions)))
    newData <- matrix(1, nrow = nrow(data), ncol = ncol(interactions),
                      dimnames = list(NULL, colnames(interactions)))
    for (l in seq_len(ncol(interactions))) {
      for (j in seq_len(nrow(interactions))) {
        newData[, l] <- newData[, l] * data[, interactions[j, l]]
      }
      if (center == "residual") {
        newData[, l] <-
          stats::resid(stats::lm(newData[, l] ~ data[, as.vector(interactions)]))
      }
    }
    data <- cbind(data, newData)
    indicatorsMapping <-
      cbind(indicatorsMapping,
            matrix(FALSE, nrow = nrow(indicatorsMapping), ncol = 1,
                   dimnames = list(NULL, rownames(interactionsMapping)[i])))
    indicatorsMapping <-
      rbind(indicatorsMapping,
            matrix(rep(c(rep(FALSE, ncol(indicatorsMapping) - 1), TRUE),
                       each = ncol(interactions)),
                   nrow = ncol(interactions),
                   dimnames = list(colnames(interactions),
                                   colnames(indicatorsMapping))))
  }
  return(structure(data,
                   mapping = indicatorsMapping*1L))
}
