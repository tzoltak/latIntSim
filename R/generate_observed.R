#' @title Data generation
#' @description
#' Generates a matrix of values of the latent variables' observed indicators
#' @param latent a matrix with values of latent variables, typically generated
#' by the [generate_latent]
#' @param loadings a matrix with values of factor loadings (with observed
#' indicators in rows and latent variables in columns), typically generated by
#' the [generate_loadings]
#' @param intercepts optionally a numeric vector of the observed indicators
#' intercept parameters (of the same length as the number of rows in `loadings`);
#' by default, the intercept of 0 is assumed for all indicators
#' @param loadingsStandardized a logical value indicating whether factor
#' loadings given by `loadings` are standardized ones (`TRUE` by default);
#' **if `FALSE`, variance of the error terms of observed indicators will be
#' fixed to 1**
#' @param latentVariances optionally a vector of variances of the latent
#' variables - **needed only if** `loadingsStandardized = TRUE`;
#' by default it is assumed that latent variables have variance of 1
#' @returns a numeric matrix of observed indicators' values with `nrow(latent)`
#' rows and `nrow(loadings)` columns; also, a matrix describing which observed
#' indicator is loaded by which latent variable(s) and matrix of unstandardized
#' loadings are returned as attributes
#' @details
#' Cross-loadings are not supported with `loadingsStandardized=TRUE`.
#' @examples
#' latent <- generate_latent(nObs = 10^5, nLV = 3, nLI = 2,
#'                           r = 0.3, partR = 0.3, partRI = 0.2)
#' loadings <- generate_loadings(c(x1 = 3, x2 = 3, x3 = 3, y = 4), 0.7)
#' observed <- generate_observed(latent, loadings)
#' head(observed)
#' @export
generate_observed <- function(latent, loadings,
                              intercepts = rep(0, nrow(loadings)),
                              loadingsStandardized = TRUE,
                              latentVariances = rep(1, ncol(latent))) {
  stopifnot(is.matrix(latent), is.numeric(latent),
            is.matrix(loadings), is.numeric(loadings),
            all(colnames(loadings) %in% colnames(latent)),
            !any(duplicated(colnames(loadings))), !anyNA(loadings),
            is.numeric(intercepts), length(intercepts) == nrow(loadings),
            !anyNA(intercepts),
            length(loadingsStandardized) == 1,
            loadingsStandardized %in% c(TRUE, FALSE),
            is.numeric(latentVariances),
            length(latentVariances) == ncol(latent), !anyNA(latentVariances))
  if (!all(colnames(latent) %in% colnames(loadings))) {
    message("Some of the LVs (in `latent`) are not mentioned in `loadings`.\n  Consequently these LVs ('",
            paste(setdiff(colnames(latent), colnames(loadings)), collapse = "', '"),
            "') will not load any observed indicators.")
  }
  if (is.null(names(latentVariances))) names(latentVariances) <- colnames(latent)
  latent <- latent[, colnames(loadings)]
  latentVariances <- latentVariances[colnames(loadings)]

  if (!loadingsStandardized) {
    errorStdDev <- rep(1, nrow(loadings))
  } else {
    stopifnot("Cross-loadings are not supported for standardized loadings." =
                all(rowSums(loadings != 0) <= 1),
              all(loadings > -1), all(loadings < 1))
    scalingFactors <-
      rowSums(apply(loadings, 2,
                    function(x) ifelse(x != 0, 1 / x[x != 0][1], 0)))
    errorStdDev <- sqrt(latentVariances[apply(loadings != 0, 1, which)] *
                          (1 - rowSums(loadings^2)) * scalingFactors^2)
    loadings <- loadings * rep(scalingFactors, each = ncol(loadings))
  }

  nObs <- nrow(latent)
  observed <- matrix(NA_real_, nrow = nObs, ncol = nrow(loadings),
                     dimnames = list(rownames(latent), rownames(loadings)))
  for (i in seq_len(ncol(observed))) {
    observed[, i] <- latent %*% loadings[i, ] +
      stats::rnorm(nrow(latent), 0, errorStdDev[i])
  }

  return(structure(observed,
                   loadings = loadings,
                   mapping = 1*(loadings != 0)))
}
#' @title Data generation
#' @description
#' Generates a matrix of factor loadings (do **not** allow cross-loadings)
#' @param nIndic a named integer vector: values give a number of observed
#' indicators for a latent variable specified by a given element's name
#' @param fun either:
#' \itemize{
#'   \item{a number specifying the value to which all loadings will be set}
#'   \item{a function that should be used to generate loadings for all the
#'         latent variables}
#'   \item{a named list of functions to be used to generate loadings for
#'         a specific latent variables (names of the list elements must match
#'         names of the `nIndic` elements)}
#' }
#' @param args optionally either:
#' \itemize{
#'   \item{a list of arguments to be passed to the `fun` (if `fun` is
#'         a function)}
#'   \item{a named list of lists of arguments to be used to functions given by
#'         the `fun` argument (names of the list elements must match
#'         names of the `fun` elements)}
#' }
#' @returns a numeric matrix of loadings with `sum(nIndic)` rows
#' and `length(nIndic)` columns
#' @details
#' Please note that function does **not** perform any checks on the generated
#' values of loadings (specifically, whether they are valid standardized
#' loadings).
#' @seealso [generate_observed], [generate_latent]
#' @examples
#' # The same value of 0.7 for all the latent variables and indicators:
#' generate_loadings(c(x1 = 3, x2 = 4, y = 5), 0.7)
#' # Different values for different latent variables, but constant across indicators:
#' generate_loadings(c(x1 = 3, x2 = 4, y = 5), list(x1 = I, x2= I, y = I),
#'                   list(x1 = list(0.7), x2 = list(0.5), y = list(0.6)))
#' # Loadings sampled from the uniform distribution:
#' generate_loadings(c(x1 = 3, x2 = 4, y = 5),
#'                   list(x1 = runif, x2= runif, y = runif),
#'                   list(x1 = list(n = 3, min = 0.5, max = 0.7),
#'                        x2 = list(n = 4, min = 0.5, max = 0.7),
#'                        y = list(n = 5, min = 0.5, max = 0.7)))
#' @export
generate_loadings <- function(nIndic, fun, args = NULL) {
  stopifnot(is.numeric(nIndic), !anyNA(nIndic),
            all(as.integer(nIndic) == nIndic), all(nIndic >= 0),
            !is.null(names(nIndic)), !any(duplicated(names(nIndic))),
            !any(names(nIndic) == ""),
            is.function(fun) ||
              (is.numeric(fun) && length(fun) == 1) ||
              (is.list(fun) && length(fun) == length(nIndic)),
            is.null(args) || is.list(args))
  if (is.numeric(fun)) {
    args <- rep(list(list(x = fun)), length(nIndic))
    fun <- rep(list(I), length(nIndic))
    names(fun) <- names(args) <- names(nIndic)
  } else if (is.function(fun)) {
    fun <- rep(list(fun), length(nIndic))
    args <- rep(list(args), length(nIndic))
    names(fun) <- names(args) <- names(nIndic)
  } else {
    stopifnot(all(sapply(fun, is.function)),
              all(names(fun) %in% names(nIndic)),
              length(args) == length(fun),
              !is.null(names(args)), all(names(args) %in% names(fun)))
  }
  loadings <- matrix(0, nrow = sum(nIndic), ncol = length(nIndic),
                     dimnames = list(paste(rep(names(nIndic), nIndic),
                                           unlist(sapply(nIndic, seq_len)),
                                           sep = "_"),
                                     names(nIndic)))
  for (i in seq_along(nIndic)) {
    loadings[sum(nIndic[seq_len(i - 1)]) + seq_len(nIndic[i]), i] <-
      do.call(fun[[names(nIndic)[i]]], args[[names(nIndic)[i]]])
  }
  return(loadings)
}
